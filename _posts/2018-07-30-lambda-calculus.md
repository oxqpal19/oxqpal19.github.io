---
layout: article
title: 维基百科翻译计划 | Lambda Calculus·λ演算
key: 
tags: 翻译
---

From Wikipedia, the free encyclopedia

---

λ（lambda）演算是一个数理逻辑中的形式系统，用以表示基于函数抽象和应用，使用变量绑定和替换的计算。这是一个通用计算模型，与图灵机等价。它在1930年代被数学家Alonzo Church第一次提出，作为他的*数学基础*研究的一部分。

λ演算包括两部分：构建λ表达式以及在其上进行规约操作。在最简单的λ演算范式中，λ表达式只用下列规则构建：

语法|名称|描述
---|---|---
x|变量|一个字母或字符串，代表一个参数或一个值
(λx.M)|抽象|函数定义（M是一个λ项）。变量x在这个表达式中被**绑定**
(M N)|应用|将一个函数应用到一个参数上。M和N都是λ项。

通过这些规则产生的表达式如` (λx.λy.(λz.(λx.z x) (λy.z y)) (x y))`。如果表达式没有歧义，圆括号可以省略。对于某些应用，逻辑学或数学常量和运算符可以被使用。

基础规约定理有两条：

操作|名称|描述
---|---|---
(λx.M[x]) → (λy.M[y])|α变换|重命名被绑定的变量。用来防止名称冲突。
((λx.M) E) → (M[x:=E])|β规约|应用函数，这个规约的“正常”写法是对于函数M(x)，计算M(E)

如果De Bruijn indexing被应用，那么α变换是不必要的---名称冲突将不存在。如果重复β规约直至不再改变，那么根据Church-Rosser理论，会产生一个β normal形式的式子。

<!--more-->

## 解释与应用

λ演算是图灵完备的，也就是说，这是一个可以用于模拟任何图灵机的通用模型。λ也被用在λ表达式和λ项中，用来表示将一个变量绑定在一个函数上。（如`λx.E`，“正常”写法类似于`E(x)`，其中λ和.基本上起到了括号的作用）

---

译者注：维基百科写的太形式化了，在这里插一段我自己的进一步解释。λ演算本质上是个匿名函数范式。比如说平常数学中可能会写`f(x)=3x+5`之类，而`f(x)=3x+5`和`g(x)=3x+5`其实是等价的。Church这人就直接把函数表达式写到了前面代替了名字，类似于`3x+5(x)`；再加上搞lisp的人整天搞前缀式和递归，所以写成了`λx.+ (* 3 x) 5`之类的鬼画符，如果有疑问可以回顾一下λ的基本规则，顺便查下前缀运算和高阶函数。

---

λ演算可以是有类型或者无类型的，在有类型λ演算中（上文所述是无类型的），函数只能在参数类型和输入类型符合时被应用。有类型λ运算（calculi）比无类型λ演算（calculus）要弱---后者是这个条目的主要部分---因为有类型的λ运算能表达的比无类型λ演算少；与此同时，前者使得更多定理能被证明。例如，在简单类型λ演算中，运算总是能够停止，然而无类型λ演算中这是不一定的（因为停机问题）。目前有许多种有类型λ演算的一个原因是它们被期望能做到更多（做到某些以前的有类型λ演算做不到的）的同时又希望能用以证明更多定理。

λ演算在数学、哲学、语言学和计算机科学中都有许多应用。它在抽象编程语言理论中占有重要地位，函数式编程实现了λ演算支持。λ演算在范畴论中也是一个研究热点。

## 历史

Church在1930年创立的最早的λ演算系统被证明是逻辑上不自洽的---在1935年Stephen Kleene和J.B. Rosser举出了Kleene-Rosser悖论。

随后，在1936年Church把那个版本的关于计算的部分抽出独立发表---现在这被称为无类型λ演算。在1940年，他创立了一个计算能力更弱但是逻辑上自洽的的系统，这被称为简单类型λ演算。

直到1960年，λ演算与编程语言的关系被确立了；在这之前它只是一个范式。由于Richard Montague和其他语言学家将λ演算应用于自然语言语法的研究，λ演算已经开始在语言学和计算机科学学界拥有一席之地。

## 非正式描述

#### 动机

可计算函数是计算机科学和数学的基础概念之一。λ演算提供了一个简单的计算语法，让计算的属性得以被正式地研究。λ演算通过包含两个简化来让语法简洁。

第一，λ演算匿名地对待函数，不给函数显式的名字。例如，函数
$$square\_sum(x,y)=x^2+y^2$$
可以被改写为匿名形式
$$(x,y) \rightarrow x^2+y^2$$
类似的，
$$id(x)=x$$
可以被改写成匿名形式
$$x \rightarrow x$$
在这个函数中，参数被简单地映射到了它自身。

第二，（原版）λ演算中的函数只是用单参函数。常见的二元函数，比如上文所述的`square_sum`，可以被改写成一个接受一个参数并给出一个新函数的“高阶函数”，而那个被给出的新函数会再接受一个参数并给出一个数。例如，
$$(x,y) \rightarrow x^2+y^2$$
可以被改写为
$$x \rightarrow (y \rightarrow x^2+y^2)$$
这一方法---被称作柯里化---把一个多元函数变成了一个返回一串函数链，其中每个函数都是一元函数的高阶函数。

对于`square_sum`函数，当它被应用到两个参数上一次时，
$$((x,y) \rightarrow x^2+y^2)(5,2)\
=5^2+2^2\
=29$$

然而被柯里化后，它的计算需要多一步
$$((x \rightarrow (y \rightarrow x^2+y^2))(5))(2)\
=(y \rightarrow 5^2+y^2)(2)\
=5^2+2^2\
=29$$

其中第一步和第二步计算类似于β规约。

# 结语

λ演算的魅力在于，这一简单的演算规则能够产生一个独特的悖论：自指。通过λ演算的高阶使用---Y组合子，我们能够构造出一个无穷递归的函数Y：对于任意特定函数f，使得$$Y(x)=Y(f(x))=Y(f(f(x)))=Y(f(f(f(x))))=...$$，而且不需要使用函数的名字Y。进而，我们得到了一个不可能计算的函数（也就证否了停机问题）。